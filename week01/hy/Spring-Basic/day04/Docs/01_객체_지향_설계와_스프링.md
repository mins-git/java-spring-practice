# 1. 객체 지향 설계와 스프링

## 이야기 - 자바 진영의 추운 겨울과 스프링의 탄생

- **과거 EJB의 대세**

  - 분산, 트랜잭션, 컨테이너 등 다양한 기능 포함 (종합선물세트)
  - 복잡하고 느림, 객체 지향적인 자바의 장점 살리지 않음

- **하이버네이트 등장**

  - 오픈소스 ORM 프레임워크
  - 이를 기반으로 자바 표준(JPA) 발전

- **스프링의 등장**
  - 로드 존슨과 유겐 휠러가 주도

## 스프링이란?

**문맥에 따라 다르다!**

- **스프링 DI 컨테이너**
- **스프링 프레임워크**
- 스프링 부트, 스프링 프레임워크 등을 모두 포함한 **스프링 생태계**

### 스프링 생태계

**스프링 프레임워크**

- **핵심 기술**
  - 스프링 DI 컨테이너, AOP, 이벤트, 기타
- **웹 기술**
  - 스프링 MVC, 스프링 WebFlux
- **데이터 접근 기술**
  - 트랜잭션, JDBC, ORM, XML
- **기타**
  - 캐시, 이메일, 원격 접근, 스케줄링
  - 스프링 기반 테스트 지원
  - 언어: 코틀린, 그루비

**스프링 부트**

- 스프링을 편리하게 사용할 수 있도록 지원
  - 단독 실행 가능 스프링 애플리케이션 생성
  - 내장 웹 서버 제공 (Tomcat 등)
  - 손쉬운 빌드 구성을 위한 starter 종속성 구성
  - 외부 라이브러리 자동 구성(버전 호환 자동 관리)
  - 메트릭, 상태 확인, 외부 구성 등 프로덕션 기능 제공(모니터링)
  - 관례에 따른 간결한 설정

**스프링의 기타 모듈**

- 스프링 데이터, 스프링 세션, 스프링 시큐리티, 스프링 Rest Docs, 스프링 배치, 스프링 클라우드 등

### 왜 스프링인가?

- 객체 지향 언어인 자바 언어 기반 프레임워크
- 이러한 장점을 잘 살려서 좋은 객체 지향 애플리케이션 개발할 수 있게 도와주는 프레임워크

## 좋은 객체 지향 프로그래밍이란?

**객체 지향 프로그래밍이란?**

- 컴퓨터 프로그램을 명령어들의 목록이 아닌 여러 객체의 모임으로 이해
- 객체는 메시지를 주고받고 데이터를 처리
- 프로그램을 유연하고 변경이 용이하게 만들어줌
  - 대규모 SW 개발에 많이 사용됨

### 역할과 구현의 분리

- 역할: 인터페이스
- 구현: 구현 클래스
- → 다형성을 통해 객체 세상으로 가져올 수 있음
- **역할 부여 및 구현 객체 생성**
  - 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
  - 클라이언트는 구현 대상의 내부 구조를 몰라도 된다.
  - 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향 받지 않는다.
  - 클라이언트는 구현 대상 자체를 변경해도 영향 받지 않는다.

**수많은 객체 클라이언트와 객체 서버는 서로 협력 관계**

- 클라이언트: 요청
- 서버: 응답

### 객체 지향의 의의

- 유연하고 변경이 용이
- 확장 가능한 설계
- 클라이언트에 영향 주지 않고 변경 가능
- 인터페이스를 안정적으로 설계하는 것이 중요
  - 역할(인터페이스) 자체가 변하면 클라이언트와 서버 모두에 큰 영향을 미치기 때문

### 스프링은 다형성 극대화

- 제어의 역전(IoC), 의존관계 주입(DI) 등

## 좋은 객체 지향 설계의 5가지 원칙 (SOLID)

- **S**: Single Responsibility Principle (SRP)
  - 단일 책임 원칙
  - 하나의 클래스는 하나의 책임만 가져야 한다
  - 하나의 책임이라는 것은 모호하다
    - 클 수 있고 작을 수 있다
    - 문맥과 상황에 따라 다르다
  - 중요한 기준은 변경! (변경이 있을 때 파급효과가 적으면 잘 따른 것)
  - UI 변경, 객체의 생성과 사용을 분리, 계층 분리
  - 범위를 너무 작게하면 기능이 너무 작게 꼬재기조, 크게하면 너무 책임이 많아짐
    - 적절하게 잘 조절하는 것이 포인트
- **O**: Open/Closed Principle (OCP)
  - 개방-폐쇄 원칙
  - 소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야 함
  - 다형성 활용!
  - 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
  - 역할과 구현의 분리
    - 즉, 구현에는 열려있고, 역할에는 닫혀있어야 함.
    - 클라이언트가 구현 클래스 직접 선택할 경우, 구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다.
    - 다형성을 사용했지만 OCP 지키지 못하는 경우도 있다.
      - 객체를 생성하고 연관 관계를 맺어주는 별도의 조립, 설정자 필요
      - 이러한 역할을 스프링 컨테이너가 해줌(DI, IoC)
- **L**: Liskov Substitution Principle (LSP)
  - 리스코프 치환 원칙
  - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
  - 어떤 인터페이스에 대한 구현체(하위 클래스)는 인터페이스 규약을 우선적으로 지켜야 한다.
- **I**: Interface Segregation Principle (ISP)
  - 특정 클라 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다
  - 기능에 맞게 적절한 범위
  - 인터페이스가 명확해지고 대체 가능성이 높아진다
  - A인터-A클라, B인터-B클라
  - A 인터페이스 자체가 변해도 B 클라이언트에 영향 주지 X
- **D**: Dependency Inversion Principle (DIP)
  - 의존관계 역전 원칙
  - 구현 클래스(구체화)에 의존하지 말고 인터페이스(추상화)에 의존하라
  - 클라이언트가 역할에 의존하게 해야 한다.
  - 그래야 유연하게 구현체 변경 가능
  - 앞서 설명한 멤서는 인터페이스에 의존하지만 구현 클래스도 동시에 의존한다. 즉, DIP를 위반한다.
  - 의존한다? 내가 저 코드를 알고있다.
  - MemberService는 MemberRepository 인터페이스만 의존하도록 설계해야 한다.

### 정리

- 객체지향의 핵심은 다형성
- 다형성 만으로는 OCP DIP 지킬 수 없음
- 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다
- 부품 갈아끼우듯 쉽게 변경할 수 없다!!

## 객체 지향 설계와 스프링

- 순수 자바로 OCP DIP 원칙을 지키면서 개발 해보니 너무 할 일이 많음
  - 프레임워크로 만들어버림(DI컨테이너)

**스프링은 다음 기술로 다형성 + OCP DIP 가능하게 지원**

- DI: 의존관계 or 의존성 주입
- DI 컨테이너 제공
  - 객체들을 컨테이너 안에 넣어놓고 서로 의존관계 주입

### 정리

- 모든 설계에 역할과 구현을 분리하자
  - (이상적으로는) 모든 설계에 인터페이스 부여하자
- 만약 어떤 것으로 기능을 구현할 지 정해지지 않았다면 인터페이스 먼저 간단히 구현해놓고 나중에 구현하기
  - 무분별하게 하면 추상화 비용 발생
- 기능을 확장할 가능성이 없다면 구체 클래스 사용 후 리팩터링하여 인터페이스 도입하는 것도 좋은 방법이다 !!
